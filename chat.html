<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chat</title>
<style>
  body {
    margin: 0; 
    font-family: Arial, sans-serif;
    background-color: #121212;
    color: #ddd;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }

  .topbar {
    background-color: #1f1f1f;
    color: #ddd;
    height: 50px;
    display: flex;
    align-items: center;
    padding: 0 15px;
    font-size: 18px;
    user-select: none;
  }
  .topbar .back {
    cursor: pointer;
    margin-right: 15px;
    font-weight: bold;
    font-size: 22px;
    line-height: 1;
    color: #ddd;
    transition: color 0.2s;
  }
  .topbar .back:hover {
    color: #4caf50;
  }
  .topbar .title {
    flex-grow: 1;
  }

  #messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px 15px;
    background-color: #181818;
  }

  .message-section {
    margin-bottom: 15px;
    border-bottom: 1px solid #333;
    padding-bottom: 8px;
  }

  .message-pseudo {
    font-weight: bold;
    font-size: 14px;
    margin-bottom: 3px;
  }
  .message-pseudo.self {
    color: #4caf50;
  }
  .message-date {
    font-size: 11px;
    color: #888;
    margin-bottom: 5px;
  }
  .message-text {
    font-size: 15px;
    white-space: pre-wrap;
  }

  #inputArea {
    background-color: #1f1f1f;
    padding: 10px 15px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  #messageInput {
    flex-grow: 1;
    padding: 8px 12px;
    font-size: 15px;
    border-radius: 4px;
    border: none;
    outline: none;
    background-color: #2a2a2a;
    color: #ddd;
  }
  #messageInput::placeholder {
    color: #666;
  }

  #sendBtn {
    background-color: #4caf50;
    border: none;
    color: white;
    padding: 8px 15px;
    font-weight: bold;
    cursor: pointer;
    border-radius: 4px;
    transition: background-color 0.2s;
  }
  #sendBtn:hover {
    background-color: #45a045;
  }
</style>
</head>
<body>

<div class="topbar">
  <div class="back" id="backBtn">&#8592;</div>
  <div class="title">Chat</div>
</div>

<div id="messages"></div>

<div id="inputArea">
  <input id="messageInput" type="text" placeholder="Écrire un message..." autocomplete="off" />
  <button id="sendBtn">Envoyer</button>
</div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script>
const firebaseConfig = {
  apiKey: "AIzaSyDQGmbiwh5LTVq0Wp1q9NrSQzs86vER2XM",
  authDomain: "kychat-45596.firebaseapp.com",
  databaseURL: "https://kychat-45596-default-rtdb.firebaseio.com",
  projectId: "kychat-45596",
  storageBucket: "kychat-45596.appspot.com",
  messagingSenderId: "104462848972",
  appId: "1:104462848972:web:7ac49e63008e9a11150369"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

let currentUser, targetUid, chatId;

// Retourne un chatId unique pour deux UIDs (ordre alphabétique)
function getChatId(uid1, uid2) {
  return uid1 < uid2 ? uid1 + "_" + uid2 : uid2 + "_" + uid1;
}

// Formate la date selon "Aujourd'hui à HH:mm", "Hier à HH:mm" ou date complète
function formatMessageDate(timestamp) {
  const date = new Date(timestamp);
  const now = new Date();

  const isToday =
    date.getDate() === now.getDate() &&
    date.getMonth() === now.getMonth() &&
    date.getFullYear() === now.getFullYear();

  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  const isYesterday =
    date.getDate() === yesterday.getDate() &&
    date.getMonth() === yesterday.getMonth() &&
    date.getFullYear() === yesterday.getFullYear();

  const hours = date.getHours().toString().padStart(2, "0");
  const minutes = date.getMinutes().toString().padStart(2, "0");

  if (isToday) return `Aujourd'hui à ${hours}:${minutes}`;
  if (isYesterday) return `Hier à ${hours}:${minutes}`;

  return date.toLocaleString();
}

// Scroll automatique vers le bas des messages
function scrollToBottom() {
  const messagesDiv = document.getElementById("messages");
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// Affiche les messages dans #messages, avec pseudo récupéré et cache
async function displayMessages(messagesObj) {
  const messagesDiv = document.getElementById("messages");
  messagesDiv.innerHTML = "";

  if (!messagesObj) return;

  const sorted = Object.values(messagesObj).sort(
    (a, b) => a.timestamp - b.timestamp
  );

  if (!displayMessages.pseudoCache) displayMessages.pseudoCache = {};
  if (!displayMessages.pdpCache) displayMessages.pdpCache = {};

  let lastMsg = null;
  let lastSection = null;

  for (const msg of sorted) {
    const isSameSender = lastMsg && lastMsg.from === msg.from;
    const isCloseInTime = lastMsg && (msg.timestamp - lastMsg.timestamp < 2 * 60 * 1000); // 2 min

    const shouldGroup = isSameSender && isCloseInTime;

    if (!shouldGroup) {
      // Nouvelle section de message
      const section = document.createElement("section");
      section.className = "message-section";

      // Pseudo
      if (!displayMessages.pseudoCache[msg.from]) {
        const snap = await db.ref(`users/${msg.from}/pseudo`).once("value");
        displayMessages.pseudoCache[msg.from] = snap.val() || "Inconnu";
      }
      const pseudo = displayMessages.pseudoCache[msg.from];

      const pseudoSpan = document.createElement("span");
      pseudoSpan.className = "message-pseudo";
      if (msg.from === currentUser.uid) pseudoSpan.classList.add("self");
      pseudoSpan.textContent = pseudo;

      // PDP
      if (!displayMessages.pdpCache[msg.from]) {
        const snap = await db.ref(`users/${msg.from}/pdp`).once("value");
        let val = snap.val() || "";
        if (val.startsWith("pdp:pdp:")) {
          val = val.split("pdp:pdp:")[1];
          val = val.replace("https://imgur.com/", "https://i.imgur.com/");
        } else {
          val = "";
        }
        displayMessages.pdpCache[msg.from] = val;
      }

      if (displayMessages.pdpCache[msg.from]) {
        const img = document.createElement("img");
        img.className = "message-pdp";
        img.src = displayMessages.pdpCache[msg.from];
        img.alt = "Photo de profil";
        img.onerror = () => (img.src = "defaultpdp.png");
        section.appendChild(img);
      }

      // Date
      const dateSpan = document.createElement("div");
      dateSpan.className = "message-date";
      dateSpan.textContent = formatMessageDate(msg.timestamp);

      // Texte
      const textDiv = document.createElement("div");
      textDiv.className = "message-text";
      textDiv.textContent = msg.text;

      // Assemble
      section.appendChild(pseudoSpan);
      section.appendChild(dateSpan);
      section.appendChild(textDiv);

      messagesDiv.appendChild(section);
      lastSection = section;
    } else {
      // Ajouter un message supplémentaire à la même section
      const textDiv = document.createElement("div");
      textDiv.className = "message-text";
      textDiv.textContent = msg.text;
      lastSection.appendChild(textDiv);
    }

    lastMsg = msg;
  }

  scrollToBottom();
}


// Charge les messages du chat en temps réel
function loadMessages() {
  if (!chatId) return;
  const messagesRef = db.ref(`chats/${chatId}/messages`);

  messagesRef.on("value", (snap) => {
    displayMessages(snap.val());
  });
}

// Envoie un message (texte non vide)
async function sendMessage(text) {
  if (!text.trim()) return;

  const messagesRef = db.ref(`chats/${chatId}/messages`);
  const newMsgRef = messagesRef.push();
  await newMsgRef.set({
    text: text.trim(),
    from: currentUser.uid,
    timestamp: Date.now(),
  });

  document.getElementById("messageInput").value = "";
}

// Met à jour la connectivité en ligne/hors-ligne dans Firebase
async function setConnectivity(state) {
  if (!currentUser) return;
  await db.ref(`users/${currentUser.uid}/connectivity`).set(state);
}

// Gestion des événements des boutons et input
document.getElementById("backBtn").addEventListener("click", () => {
  setConnectivity("offline");
  window.location.href = "home.html";
});

document.getElementById("sendBtn").addEventListener("click", () => {
  const input = document.getElementById("messageInput");
  sendMessage(input.value);
});

document.getElementById("messageInput").addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    sendMessage(e.target.value);
  }
});

// Authentification et initialisation
auth.onAuthStateChanged(async (user) => {
  if (!user) return (window.location.href = "index.html");
  currentUser = user;

  const userRef = db.ref(`users/${currentUser.uid}`);

  // Mettre online
  await userRef.child("connectivity").set("online");

  // Quand on quitte la page => offline
  window.addEventListener("beforeunload", () => {
    userRef.child("connectivity").set("offline");
  });

  // Récupérer l'UUID du destinataire
  const actualSnap = await userRef.child("actual").once("value");
  targetUid = actualSnap.val();

  if (!targetUid || targetUid === "main") {
    alert("Aucune conversation sélectionnée.");
    await userRef.child("connectivity").set("offline");
    return (window.location.href = "home.html");
  }

  chatId = getChatId(currentUser.uid, targetUid);
  loadMessages();
});

</script>

</body>
</html>
